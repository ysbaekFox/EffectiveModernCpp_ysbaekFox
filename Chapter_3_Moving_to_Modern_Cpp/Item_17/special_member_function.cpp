#include <iostream>
#include <string>
#include <map>

// specual member function이란?
// 기본 생성자, 소멸자, 복사 생성자, 복사 연산자를 의미합니다.
// 참고로, c++11 이상부터는 이동 생성자, 이동 연산자도 포함합니다.

/*
* 이 함수들은 꼭 필요한 경우에만, 다시 말해 이 함수들이 클래스에 명시적으로 선언되어 있지는 않지만 
* 이 함수들을 사용하는 클라이언트 코드가 존재할 때에만 작성됩니다.
*/

/* 
* 기본 생성자는 클래스에 생성자가 하나도 선언되어 있지 않을 때 작성됩니다.
* 특수 멤버 함수들은 암묵적으로 공개(public)이자 인라인(inline)입니다.
* 가상 소멸자가 있는 기반의 클래스를 상속하는 파생 클래스의 소멸자를 제외하고는 비가상(non virtual)입니다. (매우 중요)
* 가상 소멸자가 있는 기반 클래스를 상속하는 경우 파생 클래스의 소멸자는 가상(virtual)으로 선언됩니다.
*/

/*
* 이동 생성자(move constructor) / 이동 연산자(move assignment operator)
* - 멤버별 '이동'의 핵심은 이동할 객체(원본)에 std::move를 적용하는 것이고, 
*   그 적용 결과는 함수 중복적재 해소 과정에서 이동과 복사 중 어떤 것을 수행해야 할지를 결정하는데 쓰인다
* - 멤버별 이동이 이동 연산을 지원하는 자료 멤버들과 기반 클래스들에 대한 이동 연산들로 이루어지며, 
*   만일 이동 연산을 지원하지 않는다면 복사 연산이 수행된다.
* - 복사 연산들과 마찬가지로, 클래스 작성자가 명시적으로 선언한 이동 연산들은 자동으로 작성되지 않는다.
* - 두 복사 연산은 서로 독립적이다. 즉, 하나를 선언한다고 해서 다른 하나의 작성이 방지되지는 않는다.
* - 복사 생성자를 선언했지만 복사 배정 연산자는 선언하지 않았다면, 그러나 복사 배정 연산이 필요한 클라이언트 코드를 작성했다면, 
*   컴파일러가 자동으로 복사 배정 연산자를 작성한다.
* - 복사 배정 연산자를 선언했지만 복사 생성자는 선언하지 않았다면, 
*   그러나 복사 생성이 필요한 클라이언트 코드를 작성했다면, 컴파일러가 자동으로 복사 생성자를 작성한다.
* - 두 이동 연산은 둘 중 하나를 선언하면 컴파일러는 다른 하나를 작성하지 않는다.
* - 복사 연산(생성 또는 배정)을 하나라도 명시적으로 선언한 클래스에 대해서는 이동 연산들이 작성되지 않는다.
* - 이동 연산(생성 또는 배정)을 하나라도 명시적으로 선언하면 컴파일러는 복사 연산들을 비활성화한다.
*
* 3의 법칙(Rule of Three)
* - 만일 복사 생성자와 복사 배정 연산자, 소멸자 중 하나라도 선언했다면 나머지 둘도(즉, 셋 다) 선언해야 한다는 것이다.
* - 어떤 클래스의 복사 배정 연산의 의미를 프로그래머가 직접 지정해야 할 필요성은 거의 항상 그 클래스가 어떤 형태로든 자원 관리를 수행하기 때문에 생긴다.
* - 그런 클래스에서는 거의 항상, 한 복사 연산이 수행하는 자원 관리를 다른 복사 연산에서도 수행해야하며, 
*   클래스의 소멸자 역시 그 자원의 관리에 참여한다(보통의 경우 자원을 해제)
* - 클래스에 사용자가 선언한 소멸자가 있다는 것은 그 클래스의 복사 연산들에 단순한 멤버별 복사가 적합하지 않음을 뜻할 가능성이 크다
*   만일 클래스에 소멸자가 선언되어 있으면, 복사 연산들을 자동으로 작성하지 않는 것이 바람직하다는 결론으로 이어진다
* - 복사 연산을 하나라도 선언하면 이동 연산들의 암묵적 작성이 배제된다는 점과 그 추론의 결합에 의해, 
*   결과적으로 c++11은 사용자 선언 소멸자가 있는 클래스에 대해서는 이동 연산들을 작성하지 않는다.
*
*
* - 클래스에 대한 이동 연산들은 다음 세 조건이 모두 만족될 때에만, 그리고 필요할 때에만, 자동으로 작성된다.
*   1) 클래스에 그 어떤 복사 연산도 선언되어 있지 않다.
*   2) 클래스에 그 어떤 이동 연산도 선언되어 있지 않다.
*   3) 클래스에 소멸자가 선언되어 있지 않다.
*/

class Base
{
public:
   virtual ~Base() = default;			// 소멸자를 가상으로
   
   Base(Base&&) = default;					// 이동 지원
   Base& operator=(Base&&) = default;
   
   Base(const Base&) = default;				// 복사 지원
   Base& operator=(const Base&) = default;
};

class StringTable
{
    // 이동 연산들이 자동으로 작성되지 않는다.
    // 그러나 클래스의 복사 연산 작성에는 아무런 영향도 미치지 않는다.
    // 이동 능력에 관한 검사도 통과할 것이다. 비록 이제는 클래스의 이동이 비활성화되었지만, 이동 요청들은 아무 문제 없이 컴파일 및 실행되기 때문이다.
    // StringTable 객체를 '이동'하는 코드는 실제로는 바탕 std::map<int, std::string> 객체의 복사본을 생성한다.
    // 그리고 std::map<int, std::string>의 복사에 걸리는 시간은 이동에 걸리는 시간에 여러 자릿수의 배수를 곱한 것(이를테면 수백, 수처 배)일 수 있다.
    // 복사 연산들과 이동 연산들을 "=default"를 이용해서 명시적으로 정의했더라면 이런 문제가 없었을 것이다.

public:
   StringTable()	// 추가됨
   {
       std::cout << "Creating StringTable object" << std::endl;
   }
   
   ~StringTable()	// 추가됨
   {
       std::cout << "Destroying StringTable object" << std::endl;
   }

   StringTable(const Base&)
   {
       // 복사 지원
       std::cout << "StringTable(const Base&)" << std::endl;
   }			

   StringTable& operator=(const StringTable&)
   {
       std::cout << "StringTable operator=(const StringTable&)" << std::endl;
   }
	
    // 다른 함수들은 이전과 동일
   
#if 1 // 이동 연산 유무에 따라 아래 main 함수의 move 동작 다르게 동작 됨.
   StringTable(StringTable&&) = default;					// 이동 지원
   StringTable& operator=(StringTable&&) = default;
#endif 

private:
   std::map<int, std::string> values;
};

int main()
{
    StringTable lhs;
    StringTable rhs;

    lhs = std::move(rhs); // 이동 연산 실행되지 않음.

    return 0;
}